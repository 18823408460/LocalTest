1. jvm 的内存模式：  主内存（主存区） + 工作内存

程序中所有的变量（主线程和子线程）都存储在 主内存中， 线程的工作内存只存储 主内存变量的副本。
工作内存是每个线程自己有一个，不是共享的

2. 主内存主要包括本地方法区和堆
   工作内存： 栈 , 寄存器


3. 线程对主存的操作指令：lock，unlock，read，load，use，assign，store，write。这些行为是不可分解的原子操作


----------------------------------------------------------------------
1.  子线程修改变量的值，不管有没有加  volatile修饰，最终一定会写入 主存去，只是时间问题

2. 之所以其他的程序 有时无法读取到 更新后的变量，，有可能是由于 编译器优化
、、Thread
   while(flag){
    a++ ;                 -------->
   }

   if(flag){  // 这是编译器做的优化处理，，导致 flag对Thread不可见。。。可以加 volatile
    while(true){
     a++ ;
      }
   }


3. Jvm 的内存模型：
 Java堆是垃圾收集器管理的主要区域


              主存区                       工作内存区
        （ 堆     +     方法区 ）    +        栈
           |               |                  |
   （年轻代 + 老年代）     (永久代)        (java Jvm栈+ native Jvm栈 + PC寄存器)
       |
（Eden空间+From Survivor+To Survivor）